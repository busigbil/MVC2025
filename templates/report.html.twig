{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block head %}
{{ parent() }}
{% endblock %}

{% block content %}
<div class="content">
    <article>
        <h1>Report</h1>

        <h2 id="kmom01">Kmom01</h2>
        <p>Mina tidigare erfarenheter av objektorientering kommer främst från den objektorienterade Python-kursen på BTH samt en tidigare kurs i Java på en annan skola. Det var dock ett tag sedan jag senast arbetade med objektorienterade begrepp, men mycket känns igen.</p>
        <p>Under detta kursmoment har jag lärt mig att klasser och objekt i PHP fungerar på ett liknande sätt som i andra objektorienterade språk. En klass definieras med nyckelordet class, och innehåller properties (medlemsvariabler) som beskriver objektets tillstånd (state), samt metoder (funktioner) som definierar objektets beteende.</p>
        <p>Precis som i andra språk kan både properties och metoder ha olika nivåer av synlighet: public, protected och private. För att kapsla in data används private eller protected, medan det som ska vara tillgängligt i det publika API:t markeras med public. Det är också vanligt att använda getters och setters för att kontrollera åtkomst till privata properties, för att kunna använda sig av inkapsling och kontrollera det som användaren har tillgång till.</p>
        <p>För att referera till objektets egna metoder eller properties inom klassen används $this->propertyNamn eller $this->metodNamn(). Liksom i Python kan även en konstruktor användas för att skapa innehållet vid initiering av ett nytt objekt. En destruktor kan användas för att förstöra objekt i PHP, men är inte nödvändigt, eftersom språket automatiskt förstör minnet kopplat till objektet när det är färdigt.</p>
        <p>När jag arbetade med uppgiften me/report reflekterade jag över hur många filer och kataloger som skapas vid installation av Symfony. I uppgiften skapades routes med hjälp av Symfonys Controller-klass, som placeras i katalogen src/Controller. Dessa controller-filer innehåller logik och renderar innehåll via HTML-Twig templates, som lagras i katalogen templates/.</p>
        <p>Twig-filerna ansvarar för presentationen av innehållet, och data skickas till dem via controller-metoden render(). Här var en viktig insikt (min TIL) att datan måste struktureras som en array (på samma sätt som gjordes i övningsuppgiften) för att Twig ska kunna läsa och använda innehållet korrekt.</p>
        <p>I public-katalogen finns index.php, som fungerar som utgångspunkt för applikationen och innehåller autoloadern, vilket möjliggör automatisk inladdning av klassfiler. Jag använde katalogen assets/styles för att sätta upp SASS i projektet.</p>
        <p>Jag märkte att det fanns många kataloger och filer i Symfony som troligtvis har viktiga funktioner i en större webbapplikation, men som jag ännu inte förstått fullt ut. För ett mer professionellt projekt hade det kanske varit bättre att lagra innehåll (som denna text) i en lättviktig databas eller i markdown-filer, snarare än att skriva in dem direkt i Twig-filerna.</p>
        <p>En annan reflektion är att mycket information om PHP som finns online är inaktuell. Därför är resurser som artikeln “PHP: The Right Way” värdefulla. Jag ser särskilt användning för avsnittet Coding Practices, som ger exempel på bra kodstil och hur man t.ex. arbetar med datum.</p>
        <p>Framöver tror jag att delar om testning, säkerhet och deployment i PHP: The Right Way kan vara bra referenser, särskilt om jag i framtiden sätter upp ett eget PHP-projekt i arbetslivet.</p>

        <h2 id="kmom02">Kmom02</h2>
        <p>I detta kursmoment har jag lärt mig mer om de objektorienterade konstruktionerna arv, komposition, trait och interface. Arv och komposition är begrepp som jag känner igen sedan tidigare, medan trait och interface var nya begrepp för mig.</p>
        <p>Arv innebär att en subklass ärver medlemsvariabler och metoder från en basklass. På så sätt kan man specialisera basklassen, genom att ge den ytterligare funktioner. I PHP används nyckelordet “extends” i klassdefinitionen för att ge subklassen samma funktioner som basklassen. Det är möjligt att överlagra metoder i subklassen, och konstruktionen parent:: kan användas för att referera till basklassens medlemmar.</p>
        <p>Komposition är en konstruktion där en klass använder sig av en eller flera andra klasser. I PHP kan arv implementeras genom att skapa en klass som består av objekt från en annan klass. Objekten från den andra klassen kan exempelvis instansieras i konstruktorn. En variant av komposition är aggregation, där skillnaden är objekten har en lösare koppling i aggregation, där båda objekten kan existera oberoende av varandra.</p>
        <p>Trait är en konstruktion som påminner om arv, där metoder och medlemsvariabler kan användas av andra klasser. När klassen använder traits, blir traitsets kod en del av klassen. Ett trait kan inte existera på egen hand, och det går inte att skapa ett objekt av det. I PHP implementeras trait genom att använda “trait” i klassdeklarationen. Traits kan sedan användas i andra klasser genom att använda nyckelordet “use” inuti klassen.</p>
        <p>Ett interface är ett typ av kontrakt, där en klass förbinder sig till att erbjuda en uppsättning metoder. Ett interface innehåller ingen kod som en klass kan återanvända, utan listar de metoder som interfacet erbjuder. I PHP implementeras interface genom att använda “interface” i klassdeklarationen, och ange ett antal metoder. Det finns inga medlemsvariabler, och metoderna som anges har inget innehåll.</p>
        <p>Till inlämningsuppgiften hämtade jag inspiration från den objektorienterade kursen i Python som jag läste förra året. Jag minns att vi gjorde en liknande uppgift med en kortlek. Klassen DeckOfCards, som hanterar kortleken, blev den mest omfattande klassen i min lösning. Det berodde på kravet att alla kort skulle dras från samma kortlek och att kortleken successivt skulle minska i antal – till skillnad från övningsuppgiften där tärningar kunde slås obegränsat antal gånger med olika utfall.</p>
        <p>En stor fördel med Symfony, jämfört med hur vi arbetade i Python och Flask, är att det går att spara objekt direkt i session. Jag la till funktionalitet i DeckOfCards för att kunna skapa ett nytt objekt från en array av redan dragna kort, men tack vare möjligheten att lagra objekt i session behövde jag inte använda den funktionen. Jag kunde istället återanvända samma objekt för de olika uppgifterna.</p>
        <p>Min "TIL" (Today I Learned) för uppgiften var hur mycket enklare det är att arbeta med session när man kan spara hela objekt, istället för att behöva konstruera och rekonstruera dem vid varje sidladdning. Jag lade också lite extra arbete på metoderna för att dra ett kort från kortleken och för att sortera korten – dessa delar är jag särskilt nöjd med.</p>
        <p>En förbättring jag har funderat på är att använda traits för att återanvända kod som finns i flera klasser, till exempel metoder för att returnera alla korts värden eller för att räkna antalet kort.</p>
        <p>Vid det här laget känner jag att jag fått en bättre förståelse för hur MVC-ramverket fungerar och uppskattar sättet att dela upp koden på, även om det börjar bli många filer att hålla reda på.</p>
    
        <h2 id="kmom03">Kmom03</h2>
        <p>I detta kursmoment använde vi flödesdiagram och pseudokod för att stödja problemlösningen. Jag tyckte att framförallt flödesschemat blev en stor hjälp för hur jag skulle strukturera mitt spel, och jag tycker att min slutliga lösning blev ganska lik det som jag hade planerat i flödesschemat. Det som blev en utmaning var att lösningen skulle fungera över olika filer, exempelvis en “loop” i spelarens runda innebar att controller-route skulle använda samma kod (i PHP-filen), varje gång spelaren tryckte på en knapp i template-filen. För bankens runda räckte det att loopen kördes i PHP-filen, och returnerade hela rundan och dess resultat vid ett tillfälle.</p>
        <p>Med denna typ av problemlösning kunde jag identifiera hur lösningen borde se ut, men jag behövde fortfarande bryta ner hur jag skulle strukturera enskilda metoder, och där var inte flödesschemat till lika stor hjälp. Här hade det kunnat vara användbart att arbeta med pseudokod på ett annat sätt; för att strukturera metoderna, istället för att beskriva hela flödet. Exempelvis när jag skapade metoden som beräknade värdet på ess, utifrån vad som skulle ge den mest fördelaktiga totalpoängen.</p>
        <p>Min ursprungliga plan var att jag bara skulle använda en klass för spelet (Game), som innehöll metoder för att beräkna rundans totalpoäng, och om detta värde var större än 21. Sedan tänkte jag använda metoder från befintliga klasser, som Card, CardHand och DeckOfCards, och använda kontroller-filen för att hantera logiken i de olika klasserna.</p> 
        <p>Men jag märkte att detta blev ganska rörigt, och dessutom var det en del av uppgiften att ha så lite kod som möjligt i kontrollern. Därför skapade jag en Game-klass och en separat Player-klass, där ett objekt av player klassen skapades för både spelaren och banken. på så sätt kunde Game-klassen begränsas till att göra en spelrunda för spelaren, en spelrunda för banken, samt presentera vinnaren. Player-klassen fick ha metoder för att beräkna värdet på spelarens hand, och om värdet var över 17 eller över 21. Därmed kunde jag använda ett enskilt Game-objekt i kontrollern, istället för flera.</p>
        <p>I PHP-klassen la jag ner lite extra arbete på metoden för att beräkna det totala värdet beroende på antal ess i handen. Eftersom jag insåg att samma beräkning skulle behöva göras flera gånger vartefter spelaren drog kort, testade jag att använda mig av traits för att kunna placera denna kod i en separat fil, och återanvända den i min Game-klass. Jag såg också över hur jag använde if-else satser i klasserna, utifrån att min TIL för detta kursmoment var att i de flesta fallen inte använda else-satser, och istället använda exempelvis “Guard clause pattern” med enskilda if-satser där man kan gå ur metoden om if-satsen inte uppfylls.</p>
    </article>

</div>
{% endblock %}